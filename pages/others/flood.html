<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <base href="../../index.html">
        <link rel="stylesheet" href="Styles/Styles-Portfolio.css">
        <link rel="stylesheet" href="transitions.css">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
        <script type="module" src="swup.js"></script>
        <title>Projet - Flood</title>
    </head>
    
    <body>
        <main id="swup">
            <link rel="stylesheet" href="Styles/Styles-Projects.css">
            <link rel="stylesheet" href="Styles/Styles-Flood.css">
            <div class="topbar">
                <button class="topbarElem" id="topbar-menu" onclick="flipflopPanel()">‚ò∞</button>
                <a class="topbarElem transition-fade" id="topbar-back" onclick="closeNav()" href="pages/projects.html">ü°Ñ</a>
            </div>

            <div id="mySidePanel" class="sidepanel">
                <a href="index.html" onclick="closeNav()" target="_self">Home</a>
                <a>Projets</a>
                <a href="pages/about.html" onclick="closeNav()" target="_self">A Propos</a>
            </div>

            <div class ="transition-main" id="flood-project">
                <div id="flood-header">
                    <div class="title" id="flood-logo-title"> 
                        <img id="aaaa" src="/res/imgs/flood_title.png"></img>
                    </div>
                    <div class="page-project-tags">
                    </div>
                </div>

                <div class="content">

                    <p class="text">
                        D√©marr√© en : 2023
                    </p>
                    <article class="article">
                        <div class="text description">
                            Flood est un projet de moteur de jeu 2D ayant pour but initial d'apprendre comment les moteurs de jeux fonctionnent. 
                            Il est inspir√© par la s√©rie de <a class="hlink" href="https://www.youtube.com/@TheCherno" target="_blank">TheCherno</a> sur la cr√©ation d'un moteur 2D "<a class="hlink" href="https://hazelengine.com/" target="_blank":>Hazel</a>".
                            Flood a commenc√© comme un projet de fin d'√©tudes et continue encore son d√©veloppement.
                        </div>
                    </article>
                    
                    <article class="article" id="editor">
                        <div class="paragraph-illu" id="editor-p1">
                            <div class="paragraph text" id="editor-text">
                                Le moteur contient un √©diteur, l'interface est r√©alis√©e avec <a class="hlink" href="https://github.com/ocornut/imgui">dear ImGUI</a>, permettant de modifier diff√©rentes ressources et fonctionnalit√©s d'un projet.
                                Il est possible d'ouvrir, sauvegarder et fermer des "sc√®nes". Vous pourrez retrouver vos assets et fichiers compatibles dans <span>l'explorateur de ressources</span><sup style="color:rgb(34, 177, 76)">1</sup>.
                                Vous pourrez voir le contenu d'une "sc√®ne" dans <span>l'inspecteur de hi√©rarchie</span><sup style="color:rgb(237, 28, 36)">2</sup> et selectionner les diff√©rentes entit√©s qu'elles pourraient contenir.
                                Pour modifier les valeurs et composants d'une entit√© il suffit d'utiliser <span>l'inspecteur d'entit√©s</span><sup style="color:rgb(255, 127, 39)">3</sup>.
                                Tous ces √©l√©ments sont dockables dans la fen√™tre principale du moteur.
                            </div>
                            <img id="aside-flood1" src="/res/imgs/flood_1.png"/> 
                        </div>
                    </article>

                    <article class="article text" id="detail">
                        <div class="text Header-1">D√©tails de la cr√©ation du moteur</div>
                            <br>
                            <article class="article" id="context">
                                <div class="text" id="context-text">
                                    Pour ma derni√®re ann√©e d'√©tudes il fallait que je r√©alise un projet personnel d'√©tude, √©tant int√©ress√© par la programmation bas niveau, de par mes pr√©c√©dentes √©tudes en √©lectronique, et par
                                    la cr√©ation d'outils permettant la fluidification de cr√©ations par d'autres personnes j'ai d√©cid√© de me lancer dans la cr√©ation d'un prototype de moteur de jeu.<br>
                                    Je voulais aussi une particularit√© sp√©ciale √† cette cr√©ation, j'ai donc choisi de cr√©er et d'int√©grer de l'<abbr title="Entity Component System">ECS</abbr> au moteur.
                                </div>      
                            </article>

                            <article class="article" id="ECS">
                                <div class="text Header-2">Pourquoi l'Entity Component System ?</div>
                                <div class="hidden-element" id="ECS-Hidden">
                                    <div class="text">
                                        La gestion des "objets" de jeu est donc r√©alis√©e par l'utilisation d'une technologie <abbr title="Entity Component System">ECS</abbr>.
                                        L'ECS est une m√©thode de programmation bas√©e sur le paradigme de programmation : <abbr title="Data Driven Programming">DDP</abbr> ou encore du <abbr title="Data Oriented Programming">DOP</abbr>.
                                        L'id√©e est de baser la programmation non plus sur des objets mais sur les informations qu'ils contiennent.
                                    </div>
                                    <div class="paragraph-illu" id="OOP">
                                        <div class="text" id="OOP-text">        
                                            Aujourd'hui le paradigme de programmation le plus enseign√© est l'<abbr title="Object Oriented Programming">OOP</abbr>, celui-ci comporte 2 d√©fauts qui nous int√©ressent : 
                                            Un manque de flexibilit√© et le cache miss. Prenons pour exemple un jeu dans lequel vous avez une classe "human" et une classe "goblin", vous voulez pouvoir cr√©er des gobelins guerriers et des humains vendeurs. Pour cee faire on peut cr√©er une classe HumanShopkeeper h√©ritant de human et une classe goblinWarrior h√©ritant de goblin.
                                            Mais pour faire un gobelin vendeur il vous faudra cr√©er une troisi√®me classe, ce qui n'est pas tr√®s flexible.
                                        </div>
                                        <img src="res/imgs/OOP.png" alt="OOP Exemple CD" id="OOP-illu">
                                    </div>
                                    <div class="paragraph-illu" id="CBP">
                                        <img src="res/imgs/CBP.png" alt="CBP Exemple CD" id="CBP-illu">
                                        <div class="text" id="CBP-text">
                                            C'est pour cette raison que dans le monde du jeu vid√©o le paradigme de programmation le plus utilis√© aujourd'hui est le <abbr title="Component Based Programming">CBP</abbr>. 
                                            Ce dernier se base sur des objets, qu'on appelle "composants", que l'on rattache √† d'autres objets pour leur donner des comportements ou donn√©es diff√©rentes sans augmenter la complexit√© de l'architecture.
                                            En reprenant notre exemple pr√©c√©dent des humains et des gobelins, nous aurions deux objets principaux "Human" et "Goblin" et deux composants "Shopkeeper" et "Warrior" que l'on rattacherait √† nos objets principaux. C'est plus flexible et plus √©volutif.
                                        </div>
                                    </div>
                                    <div class="text" id="ECS-UML-text-1">
                                        Cependant cela ne r√®gle pas le probl√®me du cache miss. Ce dernier est un probl√®me li√© √† comment l'information est stock√©e en m√©moire dans nos ordinateurs et comment le processeur y acc√®de.
                                        Quand le processeur veut acc√©der √† de la m√©moire pour effectuer des actions il va prendre un "morceau" d'une certaine taille dans la RAM. Ce qui veut dire que s'il veut acc√©der aux informations d'un objet, il y a des chances qu'il prenne des informations inutiles pour l'action qu'il doit effectuer.
                                        Cela peut causer des probl√®mes de performance notamment quand les informations sont stock√©es √† des endroits diff√©rents dans la m√©moire, comme cela pourrait √™tre le cas avec des listes chain√©es.
                                    </div>
                                    <div class="text" id="ECS-UML-text-2">    
                                        Ce que l'ECS tend √† faire est de stocker toutes les informations les plus proches possible les unes des des autres, comme avec un tableau. Les composants en ECS sont compos√©s exclusivement de donn√©es et le plus possible de donn√©es contigu√´s.
                                        Les Syst√®mes sont quand √† eux sont exclusivement des actions, des fonctions, du code, qui influera sur les entit√©s poss√©dant les composants n√©cessaires √† leur fonctionnement. Ainsi comme les informations sont le plus constantes et continues possible on √©vite le cache miss.
                                    </div>
                                    <div class="text" id="ECS-UML-text-3">
                                        Suite √† ces recherches sur l'ECS j'ai commenc√© √† concevoir un d√©but de biblioth√®que logicielle que j'allais utiliser avec la SFML (API avec laquelle je suis familier) pour tester et apporter des modifications √† cette library.
                                        Voici un diagramme de classe repr√©sentant son √©tat avant la cr√©ation du projet Flood.  
                                    </div>
                                    <img id="ECS-UML" src="res/imgs/ECS_UML_CD.png" alt="UML class diagram ECS" id="ECS-UML"></img>
                                </div>
                                <a class="hidden-element-btn" id="ECS-Hidden-btn" href="javascript:FlipFlopSeeMore_2('ECS-Hidden')">(voir plus)</a><br>    
                            </article>
        
                            <article class="article" id="OpenGL">
                                <div class="text Header-2">Choix de la biblioth√®que graphique :</div>
                                <div class="hidden-element" id="OpenGL-Hidden">
                                    <div class="text" id="OGL-text-1">
                                        Un domaine de la programmation avec lequel j'√©tais le plus √©tranger √©tait la programmation graphique. J'en connaissais les fondements et les principes mais pas comment utiliser les APIs.
                                        La premi√®re chose √† faire √©tait de choisir une API. Je savais qu'il existait : DirectX, Metal, Vulkan ou encore OpenGL. DirectX √©tant uniquement d√©di√©e √† Windows et Metal √† MacOS je les ai mises de c√¥t√© pour commencer.
                                        Il me restait √† choisir entre Vulkan et OpenGL. Vulkan √©tant plus r√©cent et mis √† jour, contrairement √† OpenGL depuis 2016, je me suis renseign√© dessus. Au vu de la complexit√© et de mon objectif final, qui √©tait de faire un prototype de moteur
                                        et non uniquement un moteur de rendu j'ai pr√©f√©r√© opter pour OpenGL. De plus ce dernier est encore tr√®s pr√©sent dans l'industrie et poss√®de beaucoup plus de tutoriels pour apprendre son fonctionnement.                                     
                                    </div>
                                    <div class="paragraph-illu" id="OGL-buffer">
                                        <div class="text" id="OGL-buffer-text">
                                            Maintenant que j'avais choisi une API graphique je devais apprendre les fondamentaux de la programmation graphique. Par exemple un vertex c'est quoi ?
                                            On pense souvent qu'un vertex, un sommet en fran√ßais, est une position mais en fait c'est simplement de l'information. Un vertex peut contenir effectivement une position mais aussi une couleur, les coordonn√©es dans une texture pour l'afficher, etc... cette derni√®re doit √™tre arrang√©e toujours de la m√™me mani√®re pour interpr√©ter les donn√©es de fa√ßon coh√©rente, on appelle √ßa un Layout. <br>
                                            Pour dessiner des triangles √† l'√©cran on doit stocker dans l'ordre les vertices par trois formant les triangles. C'est le principe du Vertex Buffer, c'est dans ce dernier que l'on stockera tous les vertices. <br>
                                            Un probl√®me vient se poser quant √† l'utilisation d'un Vertex Buffer seul est la r√©p√©tition de l'information ce qui utilisera inutilement de la m√©moire. C'est l√† qu'intervient l'Index Buffer, il va permettre de stocker les indexes des vertices pour former les triangles, ainsi on √©vite bien la r√©p√©tition d'information.
                                            </div>
                                        <img id="OGL-buffer-illu" src="res/imgs/OpenGL_graph.png" alt="OpenGL buffers graphique"></img>
                                    </div>
                                    <div class="text" id="OGL-text-2">
                                        Enfin il existe un dernier objet qui est sp√©cifique a OpenGL : le vertex Array, ce dernier lie le Vertex Buffer au Layout pour √©viter de le d√©finir √† chaque image de rendu.
                                    </div>
                                    <div class="text" id="OGL-text-3">
                                        Un autre point √† voir est l'utilisation de textures. Pour pouvoir utiliser des textures il faut d'abord pouvoir les charger, pour cela j'ai utilis√© une library standard : la <a class="hlink" href="https://github.com/nothings/stb">STB</a>, plus pr√©cis√©ment pour charger une image, stb_image.
                                        Une library simple d'utilisation est en un seul fichier. Il faut juste avec OpenGL penser a retourner les datas l'image car stb enregistre une image de haut en bas et OpenGL lit l'information de bas en haut.  
                                        Ensuite j'ai appris comment utiliser les matrices de projection, ce qui servira pour les cameras. Pour les manipuler et les utiliser je me suis servi de la library de math GLM optimis√©e et pr√©vue pour √™tre utilis√©e avec OpenGL.
                                    </div>
                                </div>
                                <a class="hidden-element-btn" id="OpenGL-Hidden-btn" href="javascript:FlipFlopSeeMore_2('OpenGL-Hidden')">(voir plus)</a><br>    
                            </article>

                            <article class="article" id="create-flood">
                                <div class="text Header-2">Cr√©ation du projet, gestion des fen√™tres et syst√®me d'√©v√®ments :</div>
                                <div class="hidden-element" id="flood-create-Hidden">
                                    <div class="text">
                                        Maintenant que je m'√©tais renseign√© et avait appris les 2 points plus points les plus bloquants du projet Il √©tait temps de vraiment commencer.
                                        Comme pour mes essais avec OpenGL j'allais g√©rer les fen√™tres et des Inputs gr√¢ce √† la <a class="hlink" href="https://www.glfw.org/">GLFW</a>, qui est une API open source permettant la gestion des fen√™tres, du contexte de rendu ou encore des Inputs.
                                        Cette derni√®re est adapt√©e pour OpenGL et Vulkan et est multiplateforme (Windows, macOS...).
                                    </div>
                                    <div class="paragraph-illu" id="event-system">
                                        <div class="text" id="event-system-text">
                                        
                                            Ensuite il fallait g√©rer tous les √©v√®nements qui pourraient survenir lors de l'utilisation d'un application : d√©placer, fermer ou redimensionner une fen√™tre, d√©placer et cliquer avec la souris ou encore taper sur les touches du clavier.
                                            Dans un premier temps j'ai g√©r√© les √©v√®nements au moment o√π ils apparaissent, ce qui est plus facile √† faire mais pas id√©al. C'est encore cette version de l'Event System qui est utilis√©e dans le projet pour les √©v√®nements standards de fen√™tre, souris ou clavier.
                                            Cependant n'en √©tant pas satifait j'ai plus tard con√ßu un Event System capable d'enregistrer des √©v√®nements et de les interpr√©ter au moment voulu, en me basant sur un Event System r√©alis√© plus t√¥t par curiosit√© sur comment ces derniers pourraient fonctionner. 
                                        </div>
                                        <img src="res/imgs/event_system_CD.png" id="event-system-illu" alt="diagramme de classe de l'Event System custom">
                                    </div>  
                                </div>
                                <a class="hidden-element-btn" id="flood-create-Hidden-btn" href="javascript:FlipFlopSeeMore_2('flood-create-Hidden')">(voir plus)</a><br>    
                            </article>

                            <article class="article" id="Rendering-API">
                                <div class="text Header-2">API de rendu :</div>
                                <div class="hidden-element" id="flood-GAPI-Hidden">
                                    <div class="text">
                                        Il √©tait temps maintenant de cr√©er une API de rendu propre au projet pour commencer √† voir des choses √† l'√©cran. Pour ce faire j'ai r√©appliqu√© ce que j'avais appris avec mes tests de l'OpenGL en y ajoutant un nouveau principe : le Batch Rendering.
                                        En effet il pouvait √™tre int√©ressant de voir le fonctionnement du Batch rendring, du geometry batching. En programmation graphique un probl√®me qui se pose en termes de performance est un trop grand nombre d'appels de rendu, de Draw Call.
                                        <!--Aujourd'hui nos machines sont suffisement puissantes pour pouvoir gerer un grand nombre d'appel de rendu, cependant il est toujours bien de permettre l'optimisation quand ces techniques-->
                                    </div>
                                    <div class="paragraph-illu" id="batching">
                                        <div class="text" id="batching-text">
                                            Si l'on dessine des objets √† l'√©cran les voir de mani√®re unique est plus simple, chaque objet sera un draw call. Cependant si un trop grand nombre d'objets sont pr√©sents √† l'√©cran il devient difficile pour le GPU de suivre, c'est comme si on pointait du doigt sur une feuille √† un graphiste les emplacements o√π l'on veut des touffes d'herbe.
                                            Le geometry batching consid√®re plusieurs objets comme en √©tant un seul, on va "empiler" la g√©om√©trie de plusieurs objets dans le m√™me Vertex Buffer et ainsi cela revient √† ne dessiner qu'un seul objet. Pour continuer notre analogie, on dira au graphiste les zones o√π l'on veut des touffes d'herbe.
                                            C'est tr√®s utile pour afficher de grandes cartes utilisant des tilemaps. 
                                            Mais limiter les nombre de draw call ne signifie pas avoir de meilleurs performances, si l'on en abuse (trop) c'est m√™me l'inverse. Il faut limiter les conditions d'un draw call. De plus cette technique vient avec des inconv√©nients, par exemple il est plus difficile d'utiliser des textures, ou m√™me d'utiliser un shader diff√©rent.
                                        </div>
                                        <img src="res/imgs/geometry_batch_graph.png" alt="Geometry Batching graph" id="batching-illu">
                                    </div>
                                    <div class="text">
                                        Dans cette API on arr√™tera un Batch si l'on d√©passe un nombre de vertex, si l'on d√©passe le nombre maximal de textures stockables au GPU par OpenGL (en g√©n√©ral 32 pour un PC et 8 pour un t√©l√©phone). 
                                        L'API ne g√®re pas encore la possibilit√© de changer de shader, n'√©tant qu'un projet pour rendre de la 2D, un seul Shader peut suffire pour la plupart des applications courantes. 
                                    </div>
                                </div>
                                <a class="hidden-element-btn" id="flood-GAPI-Hidden-btn" href="javascript:FlipFlopSeeMore_2('flood-GAPI-Hidden')">(voir plus)</a><br>    
                            </article>

                            <article class="article" id="dear-ImGUI">
                                <div class="text Header-2">Interface de test :</div>
                                <div class="hidden-element" id="flood-ImGUI-Hidden">
                                    <div class="text">
                                        La base du rendu √©tant faite il faut maintenant un moyen d'avoir des retours ou de faire des modifications √† la vol√©e simplement. Et pour cela je vais utiliser <a class="hlink" href="https://github.com/ocornut/imgui">Dear ImGUI</a>. 
                                        Dear ImGUI est une library d'interface graphique utilisateur imm√©diate, ou immediate graphic user interface, qui comme son nom l'indique permet de faire des interfaces utilisateur rapidement et facilement.
                                        Cette library est facile √† prendre en main et √† utiliser, elle est utilis√©e dans beaucoup de domaines pour cr√©er des outils custom.
                                        Elle me permettra de faire des retours plus faciles √† lire qu'avec la console et aussi d'avoir les informations en temps r√©el pour d√©bugger en faisant par exemple un conteur de FPS, du nombre de triangles √† l'√©cran, de draw call.
                                    </div>
                                </div>
                                <a class="hidden-element-btn" id="flood-ImGUI-Hidden-btn" href="javascript:FlipFlopSeeMore_2('flood-ImGUI-Hidden')">(voir plus)</a><br>    
                            </article>

                            <article class="article" id="ECS-in-Flood">
                                <div class="text Header-2">Ajout de l'ECS et modifications de l'API pour le moteur :</div>
                                <div class="hidden-element" id="flood-ECS-Hidden">
                                    <div class="text">
                                        Maintenant que des interfaces sont disponibles et que l'ont peut rendre des objets √† l'image il est temps d'impl√©menter dans le projet l'ECS pr√©c√©demment √©tudi√© et con√ßu.<br>
                                        Cependant j'en ai profit√© pour apporter des modifications √† l'API qui se verront utiles dans le cadre du projet. Par exemple, d√©sormais le Manager garde lui-m√™me en m√©moire la liste des entit√©s cr√©√©es dans la sc√®ne, contenant elle-m√™me le manager.
                                        Ainsi nous avons un moyen d'acceder √† toutes ces donn√©es √† un endroit centralis√© et de les afficher gr√¢ce √† Dear ImGUI.
                                        Il est aussi possible de r√©cup√©rer une liste d'entit√©s poss√©dant certains composants via une requ√™te (query). On pourra s'en servir dans les Systems par exemple pour faire les actions que l'on veut, ou encore au d√©but ne pas utiliser les systems pour des tests ou faire des recherches dans la liste d'entit√©s.
                                        Aussi un ajout directement li√© au moteur est l'ajout d'une fonction de rappel, une callback, qui s'effectue √† l'ajout d'un composant, qui sera tr√®s pratique lors de la cr√©ation de l'√©diteur. 
                                    </div>
                                </div>
                                <a class="hidden-element-btn" id="flood-ECS-Hidden-btn" href="javascript:FlipFlopSeeMore_2('flood-ECS-Hidden')">(voir plus)</a><br>    
                                
                            </article>

                            <article class="article" id="Editor-Impl">
                                <div class="text Header-2">Cr√©ation des outils de base d'un moteur :</div>
                                <div class="hidden-element" id="flood-Editor-Hidden">
                                    <div class="text">
                                        Justement il est temps de commencer la cr√©ation de l'√©diteur, et comme ImGUI est d√©j√† pr√©sent dans le projet et que la library est tr√®s compl√®te, le docking ayant √©t√© ajout√©, le choix est tout indiqu√©.
                                        Je me suis donc attel√© √† la cr√©ation des diff√©rents panneaux d'interface pour l'utilisateur. Dans un premier temps, le "Viewport". 
                                    </div>
                                    <div class="text"> 
                                        Le Viewport est le panneau qui affichera le rendu du jeu et de l'√©diteur. Il permettra aussi de s√©lectionner les entit√©s dans la sc√®ne en cliquant dessus, du mouse picking. 
                                        Pour faire tout cela il fallait cr√©er des "framebuffer" qui, au lieu de se rendre directement dans la fen√™tre, se rendent dans une texture qui elle sera affich√©e gr√¢ce a ImGUI dans le panneau. 
                                        Faire des framebuffers permet aussi le mouse picking en rendant dans une autre texture un aplat de couleur pour tout un objet, si on clique sur un pixel d'une certaine couleur cela nous permet de savoir sur quel objet on a cliqu√© et ainsi le s√©lectionner.
                                    </div>
                                    <div class="text">
                                        Vient ensuite le panneau de hi√©rarchie de sc√®ne, il permettra d'ajouter, supprimer ou de s√©lectionner les entit√©s de la sc√®ne. 
                                        √Ä terme il pourra aussi afficher et de modifier la parent√© des entit√©s, cette m√©canique n'√©tant pas encore pr√©sente pour le moment.
                                    </div>
                                    <div class="text">
                                        J'ai aussi cr√©√© le panneau d'inspection des entit√©s, l'Inspector. Il est similaire √† celui de Unity, on s√©lectionne une entit√© et il affichera ses informations. On peut modifier le nom de l'entit√©, ajouter ou supprimer des composants et aussi d'en modifier les informations.
                                        Un cas particulier utilisant les callback pr√©c√©demment vu est le composant de cam√©ra. En ajoutant ce dernier il faut modifier la taille du rendu de la cam√©ra aux dimensions du Viewport, sinon l'image sera d√©form√©e.
                                    </div>

                                    <div class="paragraph-illu" id="panels-illus">
                                        <img src="res/gifs/hierarchy_panel.gif" alt="Panneau de hi√©rarchie" id="hierarchy-panel"></img>
                                        <img src="res/gifs/inspector_panel.gif" alt="Panneau d'Inspection" id="inspector-panel"></img>
                                    </div>
                                </div>
                                <a class="hidden-element-btn" id="flood-Editor-Hidden-btn" href="javascript:FlipFlopSeeMore_2('flood-Editor-Hidden')">(voir plus)</a><br>
                                
                            </article>

                            <article class="article" id="Assets">
                                <div class="text Header-2">Gestion et utilisation de Assets :</div>
                                <div class="hidden-element" id="flood-Assets-Hidden">
                                    <div class="text">
                                        /!\ To write /!\<br>
                                        Creation d'un nouveau panneau permettant de visualiser ressources du projet.
                                        Utilise OpenFileDialogs, une raison de pourquoi le projet est d√©pendant de Windows pour le moment.
                                        Drag and drop des assets dans les autres panneaux comme des textures pour les entit√©s ou les scenes dans le viewport. 
                                        <br>/!\ ========= /!\
                                    </div>
                                </div>
                                <a class="hidden-element-btn" id="flood-Assets-Hidden-btn" href="javascript:FlipFlopSeeMore_2('flood-Assets-Hidden')">(voir plus)</a><br>    
                            </article>
                            <!--
                                Flow:

                              ‚úì ECS
                                Learn OpenGL
                                Create Flood project : Window abstraction + Event system
                                Dear ImGui
                                Input handeling
                                Rendering API -> Implement OpenGL
                                Add ECS
                                Editor(viewport, hierarchy, properties(Inspector))
                                "Assets" -> Openfiledialog -> Content browser
                            -->                  
                    </article>

                    

                    <article class="article" id="roadmap">
                        <div class="paragraph">
                            <div class="Header-1" style="margin-bottom:25px;">Roadmap:</div>
                            <div class="text" style="margin-bottom:25px;">
                                Flood n'est, pour le moment, disponible que sous Windows et utilise OpenGL pour le rendu, il sera √† terme, dans l'id√©al, multiplateforme et permettra de choisir l'API graphique.
                            </div>    
                            <!--<br>Ajouter un gestionnaire d'assets.
                            <br>Ajouter du son avec OpenAL ou via un moteur de son disponible (FMod, Wwise...).
                            <br>Retravailler l'API graphique en ajoutant Vulkan.
                            <br>Modifier l'API ECS afin d'en am√©liorer les performance g√©n√©rale (m√©moire, simplicit√©e d'utilisation, automatisation, etc...)-->
                        </div>
                        <img src="res/imgs/Flood_Roadmap.png" alt="" id="Flood-roadmap" style="width:100%;">
                    </article>

                    <div class="paragraph text" id="project-footer">
                        <p class="text footer-crea">Projet cr√©√© dans le cadre de fin d'√©tude √† <a class="hlink" href="www.creajeux.fr">Creajeux</a> l'√©cole des m√©tiers du jeu-vid√©o √† N√Æmes en France.</p>
                    </div>
                </div>
            </div>
        </main>
        <script src="js/Portfolio-JS.js">
            PushTagsInGrid("flood");
        </script>
    </body>
</html>


