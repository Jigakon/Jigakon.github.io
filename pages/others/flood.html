<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <base href="../../index.html">
        <link rel="stylesheet" href="Styles/Styles-Portfolio.css">
        <link rel="stylesheet" href="transitions.css">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
        <script type="module" src="swup.js"></script>
        <title>Projet - Flood</title>
    </head>
    
    <body>
        <main id="swup">
            <link rel="stylesheet" href="Styles/Styles-Projects.css">
            <link rel="stylesheet" href="Styles/Styles-Flood.css">
            <div class="topbar">
                <button class="topbarElem" id="topbar-menu" onclick="flipflopPanel()">‚ò∞</button>
                <a class="topbarElem transition-fade" id="topbar-back" onclick="closeNav()" href="pages/projects.html">ü°Ñ</a>
            </div>

            <div id="mySidePanel" class="sidepanel">
                <a href="index.html" onclick="closeNav()" target="_self">Home</a>
                <a>Projets</a>
                <a href="pages/about.html" onclick="closeNav()" target="_self">A Propos</a>
            </div>

            <div class ="transition-main" id="flood-project">
                <div id="flood-header">
                    <div class="title" id="flood-logo-title"> 
                        <img id="aaaa" src="/res/imgs/flood_title.png"></img>
                    </div>
                    <div class="page-project-tags">
                    </div>
                </div>

                <div class="content">

                    <p class="text">
                        D√©marr√© en : 2023
                    </p>
                    <article class="article">
                        <div class="text description">
                            Flood est un projet de moteur de jeu 2D ayant pour but initial d'apprendre comment ils fonctionnent. 
                            Il est inspir√© par la s√©rie de <a class="hlink" href="https://www.youtube.com/@TheCherno" target="_blank">TheCherno</a> sur la cr√©ation d'un moteur 2D "<a class="hlink" href="https://hazelengine.com/" target="_blank":>Hazel</a>".
                            Flood a commenc√© comme un projet de fin d'√©tude et continue encore son d√©veloppement.
                        </div>
                    </article>
                    
                    <article class="article" id="editor">
                        <div class="paragraph-illu" id="editor-p1">
                            <div class="paragraph text" id="editor-text">
                                Le moteur contient un √©diteur, l'interface est r√©alis√©e avec <a class="hlink" href="https://github.com/ocornut/imgui">dear ImGUI</a>, permettant de modifier diff√©rentes ressources et fonctionnalit√©s d'un projet.
                                Il est possible d'ouvrir, sauvegarder et fermer des "sc√®nes". Vous pourrez retrouver vos assets et fichiers compatibles dans <span>l'explorateur de ressources</span><sup style="color:rgb(34, 177, 76)">1</sup>.
                                Vous pourrez voir le contenu d'une "sc√®ne" dans <span>l'inspecteur de hi√©rarchie</span><sup style="color:rgb(237, 28, 36)">2</sup> et selectionner les diff√©rentes entit√©s qu'elles pourraient contenir.
                                Pour modifier les valeurs et composants d'une entit√©s il suffit d'utiliser <span>l'inspecteur d'entit√©s</span><sup style="color:rgb(255, 127, 39)">3</sup>.
                                Toutes ces √©l√©ments sont dockables dans la fen√™tre princiale du moteur.
                            </div>
                            <img id="aside-flood1" src="/res/imgs/flood_1.png"/> 
                        </div>
                    </article>

                    <article class="article text" id="detail">
                        <div class="text Header-1">D√©tail de la cr√©ation du moteur</div>
                            <br>
                            <article class="article" id="context">
                                <div class="text" id="context-text">
                                    Pour ma derni√®re ann√©e d'√©tude il fallait que je r√©alise un projet personnel d'√©tude, √©tant int√©ress√© par la programmation bas niveau, de part mes pr√©c√©dentes √©tudes en √©lectronique, et par
                                    la cr√©ation d'outils permettant la fluidification de cr√©ations par d'autres personnes j'ai d√©cid√© de me lancer dans la cr√©ation d'un prototype de moteur de jeu.<br>
                                    Je voulais aussi une particularit√© sp√©ciale √† cette cr√©ation, j'ai donc choisi de cr√©er et d'int√©grer de l'<abbr title="Entity Component System">ECS</abbr> au moteur.
                                </div>      
                            </article>

                            <article class="article" id="ECS">
                                <div class="text Header-2">Pourquoi l'Entity Component System ?</div>
                                <div class="hidden-element" id="ECS-Hidden">
                                    <div class="text">
                                        La gestion des "objets" de jeu est donc r√©alis√©e par l'utilisation d'une technologie <abbr title="Entity Component System">ECS</abbr>.
                                        L'ECS est une m√©thode de programmation bas√©e sur le paradigme de programmation : <abbr title="Data Driven Programming">DDP</abbr> ou encore du <abbr title="Data Oriented Programming">DOP</abbr>.
                                        L'id√©e est de baser la programmation non plus sur des objets mais sur les informations qu'ils contiennent.
                                    </div>
                                    <div class="paragraph-illu" id="OOP">
                                        <div class="text" id="OOP-text">        
                                            Aujourd'hui le paradigme de programmation le plus enseign√© est l'<abbr title="Object Oriented Programming">OOP</abbr>, celui comporte 2 d√©fauts qui nous int√©resses. 
                                            Un manque de flexibilit√© et le cache miss. Prenons pour exemple un jeu dans lequel vous avez une classe "human" et une classe "goblin", vous voulez pouvoir des gobelins guerrier et des humains vendeurs. Pour se faire on peut cr√©er une classe HumainShopkeeper h√©ritant de human et une classe goblinWarrior h√©ritant de goblin.
                                            Mais pour faire un gobelin vendeur il vous faudra cr√©er une troisi√®me classe, ce qui n'est pas tr√®s flexible.
                                        </div>
                                        <img src="res/imgs/OOP.png" alt="OOP Exemple CD" id="OOP-illu">
                                    </div>
                                    <div class="paragraph-illu" id="CBP">
                                        <img src="res/imgs/CBP.png" alt="CBP Exemple CD" id="CBP-illu">
                                        <div class="text" id="CBP-text">
                                            C'est pour cette raison que dans le monde du jeu vid√©o le paradigme de programmation le plus utilis√© aujourd'hui est le <abbr title="Component Based Programming">CBP</abbr>. 
                                            Ce dernier se base sur des objets, qu'on appelle "composants", que l'on rattache √† d'autres objets pour leur donner des comportements ou donn√©es diff√©rentes sans augmenter la complexit√©e de l'architecture.
                                            En reprenant notre exemple pr√©c√©dent des humains et des gobelins, nous aurions deux objets principaux "Human" et "Goblin" et deux composants "Shopkeeper" et "Warrior" que l'on rattacheraient √† nos objets principaux. C'est plus flexible et plus √©volutif.
                                        </div>
                                    </div>
                                    <div class="text" id="ECS-UML-text-1">
                                        Cependant cela ne r√®gle pas le probl√®me du cache miss. Ce dernier est un probl√®me li√© √† comment l'information est stock√©e en m√©moire dans nos ordinateurs et comment le processeur y acc√®de.
                                        Quand le processeur veut acc√©der √† de la m√©moire pour effectuer des actions il va prendre un "morceau" d'une certaine taille dans la RAM. Ce qui veut dire que s'il veut acceder aux informations d'un objet, il y a des chances qu'il prenne des informations inutiles a l'action qu'il doit effectuer.
                                        Cela peut causer des probl√®mes de performance notamment quand les informations sont stock√©s a des endroit diff√©rents dans la m√©moire, comme cela pourrait √™tre le cas avec des listes chain√©es.
                                    </div>
                                    <div class="text" id="ECS-UML-text-2">    
                                        Ce que l'ECS tend √† faire est de stocker toutes les informations les plus proche possible les unes des des autres, comme avec un tableau. Les composants en ECS sont compos√©s exclusivement de donn√©es et le plus possible de donn√©es contigu√´.
                                        Les Syst√®mes quand √† eux sont exclusivements des actions, des fonctions, du code, qui influra sur les entit√©s possedant les composant n√©cessaire √† son fonctionnement. Ainsi comme les informations sont le plus constante et continue possible on √©vite le cache miss.
                                    </div>
                                    <div class="text" id="ECS-UML-text-3">
                                        Suite √† ces recherches sur l'ECS j'ai commenc√© √† concevoir un d√©but de biblioth√®que logicielle que j'allais utiliser avec la SFML (API avec laquelle je suis familier) pour tester et apporter des modifications √† cette library.
                                        Voici un diagramme de classe repr√©sentant son √©tat avant la cr√©ation du projet Flood.  
                                    </div>
                                    <img id="ECS-UML" src="res/imgs/ECS_UML_CD.png" alt="UML class diagram ECS" id="ECS-UML"></img>
                                </div>
                                <a class="hidden-element-btn" id="ECS-Hidden-btn" href="javascript:FlipFlopSeeMore_2('ECS-Hidden')">(voir plus)</a><br>    
                            </article>
        
                            <article class="article" id="OpenGL">
                                <div class="text Header-2">Choix de la biblioth√®que graphique :</div>
                                <div class="hidden-element" id="OpenGL-Hidden">
                                    <div class="text" id="OGL-text-1">
                                        Un domaine de la programmation avec lequel j'√©tais le plus √©tranger √©tait la programmation graphique. J'en connaissais les fondements et les principes mais pas comment utiliser les APIs.
                                        La premi√®re chose √† faire √©tait de choisir une API. Je savais qu'il existait : DirectX, Metal, Vulkan ou encore OpenGL. DirectX √©tant uniquement d√©di√©e √† Windows et Metal √† MacOS je les ait mises de cot√© pour commencer.
                                        Il me restait √† choisir entre Vulkan et OpenGL. Vulkan √©tant plus r√©cent et mis a jour, contrairement √† OpenGL depuis 2016, je me suis renseign√© dessus. Au vu de la complexit√© et de mon objectif final, qui √©tait de faire un prototype de moteur
                                        et non uniquement un moteur de rendu j'ai pr√©f√©r√© opter pour OpenGL. De plus ce dernier est encore tr√®s pr√©sent dans l'industrie et poss√®de beaucoup plus de tutoriels pour apprendre son fonctionnement.                                     
                                    </div>
                                    <div class="paragraph-illu" id="OGL-buffer">
                                        <div class="text" id="OGL-buffer-text">
                                            Maintenant que j'avais choisi une API graphique je devais apprendre les fondamentaux de la programmation graphique. Par exemple un vertex c'est quoi ?
                                            On pense souvent qu'un vertex, un sommet en fran√ßais, est une position mais en fait c'est simplement de l'information. Un vertex peut contenir effectivement une position mais aussi une couleur, les coordonn√©es dans une texture pour l'afficher, etc... cette derni√®re doit √™tre arrang√©e toujours de la m√™me mani√®re pour interpr√©ter les donn√©es de fa√ßon coh√©rente, on appelle √ßa un Layout. <br>
                                            Pour dessiner des triangles √† l'√©cran on doit stocker dans l'ordre les vertices par trois formant les triangles. C'est le principe du Vertex Buffer, c'est dans ce dernier que l'on stockera tous les vertices. <br>
                                            Un probl√®me vient se poser quand a l'utilisation d'un Vertex Buffer seul est la r√©p√©tition de l'information ce qui utilisera inutilement de la m√©moire. C'est l√† qu'intervient l'Index Buffer, il va permettre de stocker les indexes des vertices pour former les triangles, ainsi on √©vite bien la r√©p√©tion d'information.
                                            </div>
                                        <img id="OGL-buffer-illu" src="res/imgs/OpenGL_graph.png" alt="OpenGL buffers graphique"></img>
                                    </div>
                                    <div class="text" id="OGL-text-2">
                                        Enfin il existe un dernier objet qui est sp√©cifique a OpenGL : le vertex Array, de dernier lie le Vertex Buffer au Layout pour √©viter de le d√©finir √† chaque image de rendu.
                                    </div>
                                    <div class="text" id="OGL-text-3">
                                        Un autre point √† voir est l'utilisation de textures. Pour pouvoir utiliser des texture il faut d'abord pouvoir les charger, pour cela j'ai utilis√© une library standard : la <a href="https://github.com/nothings/stb">STB</a>, plus pr√©cis√©ment pour charger une image, stb_image.
                                        Une library simple d'utilisation est en un seul fichier. Il faut juste avec OpenGL penser a retourner les datas l'image car stb enregistre une image dehaut en bas et OpenGL lis l'information de bas en haut.  
                                        Ensuite j'ai appris comment utiliser les matrices de projection, ce qui servira pour les cameras. Pour les manipuler et les utiliser je me suis servi de la library de math GLM optimis√©e et pr√©vue pour √™tre utilis√©e avec OpenGL.
                                    </div>
                                </div>
                                <a class="hidden-element-btn" id="OpenGL-Hidden-btn" href="javascript:FlipFlopSeeMore_2('OpenGL-Hidden')">(voir plus)</a><br>    
                            </article>

                            <article class="article" id="create-flood">
                                <div class="text Header-2">Cr√©ation du projet, gestion des fen√™tres et syst√®me d'√©v√®ments :</div>
                                <div class="hidden-element" id="flood-create-Hidden">
                                    <div class="text">
                                        Maintenant que je m'√©tais renseign√© et avait appris les 2 plus points les plus bloquant du projet Il √©tait temps de vraiment commencer.
                                        Comme pour mes essais avec OpenGL j'allais g√©rer les gestion des fen√™tres et des Inputs gr√¢ce √† la <a href="https://www.glfw.org/">GLFW</a>, qui est une API open source permettant la gestion des f√™netres, du contexte de rendu ou encore des Inputs.
                                        Cette derni√®re est adapt√© pour OpenGL et Vulkan et est multiplateforme (Windows, macOS...).
                                    </div>
                                    <div class="paragraph-illu" id="event-system">
                                        <div class="text" id="event-system-text">
                                        
                                            Ensuite il fallait g√©rer tous les √©v√®nements qui pourraient subvenir lors de l'utilisation d'un application : d√©placer, fermer ou redimensionner une fen√™tre, d√©placer et cliquer avec la souris ou encore ta√™r sur les touches du clavier.
                                            Dans un premier temps j'ai g√©r√© les √©v√®nements au moment o√π ils apparaissent, ce qui est plus facile √† faire mais pas id√©al. C'est encore cette version de l'Event System qui est utilis√© dans le projet pour les ev√®nements standards de fen√™tre, souris ou clavier.
                                            Cependant n'en √©tant pas satifais j'ai plus tard con√ßu un Event System capable d'enregistrer des √©v√®nements et de les interpr√©ter au moment voulu, en me basant sur un Event System r√©alis√© plus t√¥t par curiosit√© sur comment ces derniers pourraient marcher. 
                                        </div>
                                        <img src="res/imgs/event_system_CD.png" id="event-system-illu" alt="diagramme de classe de l'Event System custom">
                                    </div>  
                                </div>
                                <a class="hidden-element-btn" id="flood-create-Hidden-btn" href="javascript:FlipFlopSeeMore_2('flood-create-Hidden')">(voir plus)</a><br>    
                            </article>

                            <article class="article" id="Rendering-API">
                                <div class="text Header-2">API de rendu :</div>
                                <div class="hidden-element" id="flood-GAPI-Hidden">
                                    <div class="text">
                                        Il √©tait temps maintenant de cr√©er une API de rendu propre au projet pour commencer √† voir des choses √† l'√©cran. Pour ce faire j'ai r√©appliquer ce que j'avais appris avec mes tests de l'OpenGL en y ajoutant un nouveau principe : le Batch Rendering.
                                        En effet il pouvait √™tre int√©ressant de voir le fonctionnement du Batch rendring, du geometry batching. En programmation graphique un probl√®me qui se pose en terme de performance est un trop grand nombre d'appel de rendu, de Draw Call.
                                        <!--Aujourd'hui nos machines sont suffisement puissantes pour pouvoir gerer un grand nombre d'appel de rendu, cependant il est toujours bien de permettre l'optimisation quand ces techniques-->
                                    </div>
                                    <div class="paragraph-illu" id="batching">
                                        <div class="text" id="batching-text">
                                            Si l'ont dessine des objets √† l'√©cran les voir de mani√®re unique est plus simple, chaque objet sera un draw call. Cependant si un trop grand nombre d'objets sont pr√©sent √† l'√©cran il devient difficile pour le GPU de suivre, c'est comme si on pointait du doigt sur une feuille un a graphiste les emplacements o√π l'on veut des touffes d'herbe.
                                            Le geometry batching consid√®re plusieurs objets comme en √©tant un seul, on va "empiler" la g√©om√©trie de plusieurs objets dans le m√™me Vertex Buffer et ainsi cel√† revient √† ne dessiner qu'un seul objet, pour continuer notre analogie, on dira au graphiste les zones o√π l'on veut des touffes d'herbe.
                                            C'est tr√®s utile pour afficher de grandes cartes utilisant des tilemaps. 
                                            Mais limiter les nombre de draw call ne sinifie pas avoir de meilleurs performances, si l'on en abuse trop c'est m√™me l'inverse. Il faut limiter les conditions d'un draw call. De plus cette technique vient avec des inconv√©niants, par exemple il est plus difficile d'utiliser des textures, ou m√™me d'utiliser un shader diff√©rent.
                                        </div>
                                        <img src="res/imgs/geometry_batch_graph.png" alt="Geometry Batching graph" id="batching-illu">
                                    </div>
                                    <div class="text">
                                        Dans cette API on arr√™tera un Batch si l'ont d√©passe un nombre de vertex, si l'on d√©passe le nombre maximal de textures stockable au GPU par OpenGL (en g√©n√©ral 32 pour un PC et 8 pour un t√©l√©phone). 
                                            L'API ne g√®re pas encore la possibilt√© de changer de shader, n'√©tant qu'un projet pour rendre de la 2D, un seul Shader peut suffire pour a plus part des applications courantes. 
                                    </div>
                                </div>
                                <a class="hidden-element-btn" id="flood-GAPI-Hidden-btn" href="javascript:FlipFlopSeeMore_2('flood-GAPI-Hidden')">(voir plus)</a><br>    
                            </article>

                            <article class="article" id="dear-ImGUI">
                                <div class="text Header-2">Interface de test :</div>
                                <div class="hidden-element" id="flood-ImGUI-Hidden">
                                    <div class="text">
                                        Maintenant 
                                        Bonne lib de rendu graphic user interface imm√©diate, facile a prendre en main et d'utilisation. Permettra des retour plus facile a lire qu'a la console et permettra du temps reel pour debug, compteur FPS, nb d'objets rendu a l'√©crans, etc...
                                    </div>
                                </div>
                                <a class="hidden-element-btn" id="flood-ImGUI-Hidden-btn" href="javascript:FlipFlopSeeMore_2('flood-ImGUI-Hidden')">(voir plus)</a><br>    
                            </article>

                            <article class="article" id="ECS-in-Flood">
                                <div class="text Header-2">Ajout de l'ECS et modifications de l'API  pour le moteur :</div>
                                <div class="hidden-element" id="flood-ECS-Hidden">
                                    <div class="text">
                                        Impl lib ECS custom dans moteur + ajouter modif : -manager capable lister entit√©s -recuperer liste entit√© avec certains composants via queries -callback quand composant ajout√© car vient la cr√©ation √©diteur
                                    </div>
                                </div>
                                <a class="hidden-element-btn" id="flood-ECS-Hidden-btn" href="javascript:FlipFlopSeeMore_2('flood-ECS-Hidden')">(voir plus)</a><br>    
                                
                            </article>

                            <article class="article" id="Editor-Impl">
                                <div class="text Header-2">Cr√©ation des outils de bases d'un moteur :</div>
                                <div class="hidden-element" id="flood-Editor-Hidden">
                                    <div class="text">
                                        cr√©ation de tous les panneaux d'interfaces pour manipulation utilisateur
                                        Viewport : creation de Framebuffer pour rendre scene dans une texture a afficher dans panneau ImGUI pour servir de rendu visuel + selectionner entit√©s par click picking
                                        Inspector : permet modifier toutes les infos entit√©s selectionn√©es, ajouter/supprimer composants avant lancement de la scene, changer entit√© nom...
                                        Hierarchy : Ajouter/supprimer Entit√©s dans la scene, les selectionner et a terme, donc pas encore dispo, le parentage des entit√©s entre elles 
                                    </div>
                                </div>
                                <a class="hidden-element-btn" id="flood-Editor-Hidden-btn" href="javascript:FlipFlopSeeMore_2('flood-Editor-Hidden')">(voir plus)</a><br>    
                                
                            </article>

                            <article class="article" id="Assets">
                                <div class="text Header-2">Gestion et utilisation de Assets :</div>
                                <div class="hidden-element" id="flood-Assets-Hidden">
                                    <div class="text">
                                        Creation d'un nouveau panneau permettant de visualiser ressources du projet.
                                        Utilise OpenFileDialogs, une raison de pourquoi le projet est d√©pendant de Windows pour le moment.
                                        Drag and drop des assets dans les autres panneaux comme des textures pour les entit√©s ou les scenes dans le viewport. 
                                    </div>
                                </div>
                                <a class="hidden-element-btn" id="flood-Assets-Hidden-btn" href="javascript:FlipFlopSeeMore_2('flood-Assets-Hidden')">(voir plus)</a><br>    
                            </article>
                            <!--
                                Flow:

                              ‚úì ECS
                                Learn OpenGL
                                Create Flood project : Window abstraction + Event system
                                Dear ImGui
                                Input handeling
                                Rendering API -> Implement OpenGL
                                Add ECS
                                Editor(viewport, hierarchy, properties(Inspector))
                                "Assets" -> Openfiledialog -> Content browser
                            -->                  
                    </article>

                    

                    <article class="article" id="roadmap">
                        <div class="paragraph">
                            <div class="Header-1" style="margin-bottom:25px;">Roadmap:</div>
                            <div class="text" style="margin-bottom:25px;">
                                Flood n'est, pour le moment, disponible que sous Windows et utilise OpenGL pour le rendu, il sera √† terme, dans l'id√©al, multiplateforme et permettra de choisir l'API graphique.
                            </div>    
                            <!--<br>Ajouter un gestionnaire d'assets.
                            <br>Ajouter du son avec OpenAL ou via un moteur de son disponible (FMod, Wwise...).
                            <br>Retravailler l'API graphique en ajoutant Vulkan.
                            <br>Modifier l'API ECS afin d'en am√©liorer les performance g√©n√©rale (m√©moire, simplicit√©e d'utilisation, automatisation, etc...)-->
                        </div>
                        <img src="res/imgs/Flood_Roadmap.png" alt="" id="Flood-roadmap" style="width:100%;">
                    </article>

                    <div class="paragraph text" id="project-footer">
                        <p class="text footer-crea">Projet cr√©√© dans le cadre de fin d'√©tude √† <a class="hlink" href="www.creajeux.fr">Creajeux</a> l'√©cole des m√©tiers du jeu-vid√©o √† N√Æmes en France.</p>
                    </div>
                </div>
            </div>
        </main>
        <script src="js/Portfolio-JS.js">
            PushTagsInGrid("flood");
        </script>
    </body>
</html>


