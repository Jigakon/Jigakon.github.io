<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <base href="../../index.html">
        <link rel="stylesheet" href="Styles/Styles-Portfolio.css">
        <link rel="stylesheet" href="transitions.css">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
        <script type="module" src="swup.js"></script>
        <title>Projet - Flood</title>
    </head>
    
    <body>
        <main id="swup">
            <link rel="stylesheet" href="Styles/Styles-Projects.css">
            <link rel="stylesheet" href="Styles/Styles-Flood.css">
            <div class="topbar">
                <button class="topbarElem" id="topbar-menu" onclick="flipflopPanel()">‚ò∞</button>
                <a class="topbarElem transition-fade" id="topbar-back" onclick="closeNav()" href="pages/projects.html">ü°Ñ</a>
            </div>

            <div id="mySidePanel" class="sidepanel">
                <p>Projets</p>
                <a href="pages/about.html" onclick="closeNav()" target="_self">A Propos</a>
                <a href="pages/contact.html" onclick="closeNav()" target="_self">Contact</a>
            </div>

            <div class ="transition-main" id="flood-project">
                <div id="flood-header">
                    <div class="title" id="flood-logo-title"> 
                        <img id="aaaa" src="/res/imgs/flood_title.png"></img>
                    </div>
                    <div class="page-project-tags">
                    </div>
                </div>

                <div class="content">

                    <p class="text">
                        D√©marr√© en : 2023
                    </p>
                    <article class="article">
                        <div class="text description">
                            Flood est un projet de moteur de jeu 2D ayant pour but initial d'apprendre comment ils fonctionnent. 
                            Il est inspir√© par la s√©rie de <a class="hlink" href="https://www.youtube.com/@TheCherno" target="_blank">TheCherno</a> sur la cr√©ation d'un moteur 2D "<a class="hlink" href="https://hazelengine.com/" target="_blank":>Hazel</a>".
                            Flood a commenc√© comme un projet de fin d'√©tude et continue encore son d√©veloppement.
                        </div>
                    </article>
                    
                    <article class="article" id="editor">
                        <div class="paragraph-illu" id="editor-p1">
                            <div class="paragraph text" id="editor-text">
                                Le moteur contient un √©diteur, l'interface est r√©alis√©e avec <a class="hlink" href="https://github.com/ocornut/imgui">dear ImGUI</a>, permettant de modifier diff√©rentes ressources et fonctionnalit√©s d'un projet.
                                Il est possible d'ouvrir, sauvegarder et fermer des "sc√®nes". Vous pourrez retrouver vos assets et fichiers compatibles dans <span>l'explorateur de ressources</span><sup style="color:rgb(34, 177, 76)">1</sup>.
                                Vous pourrez voir le contenu d'une "sc√®ne" dans <span>l'inspecteur de hi√©rarchie</span><sup style="color:rgb(237, 28, 36)">2</sup> et selectionner les diff√©rentes entit√©s qu'elles pourraient contenir.
                                Pour modifier les valeurs et composants d'une entit√©s il suffit d'utiliser <span>l'inspecteur d'entit√©s</span><sup style="color:rgb(255, 127, 39)">3</sup>.
                                Toutes ces √©l√©ments sont dockables dans la fen√™tre princiale du moteur.
                            </div>
                            <img id="aside-flood1" src="/res/imgs/flood_1.png"/> 
                        </div>
                    </article>

                    <article class="article" id="detail">
                        D√©tail de la cr√©ation du moteur.
                        <div class="hidden-text" id="flood-context">
                            <br>
                            <article class="article" id="context">
                                <div class="text" id="context-text">
                                    Pour ma derni√®re ann√©e d'√©tude il fallait que je r√©alise un projet personnel d'√©tude, √©tant int√©ress√© par la programmation bas niveau, de part mes pr√©c√©dentes √©tudes en √©lectronique, et par
                                    la cr√©ation d'outils permettant la fluidification de cr√©ations par d'autres personnes j'ai d√©cid√© de me lancer dans la cr√©ation d'un prototype de moteur de jeu.<br>
                                    Je voulais aussi une particularit√© sp√©ciale √† cette cr√©ation, j'ai donc choisi de cr√©er et d'int√©grer de l'<abbr title="Entity Component System">ECS</abbr> au moteur.
                                </div>
                            </article>

                            

                        </div>
                        <a class="hlink" id="flood-context-btn" href="javascript:FlipFlopSeeMore('flood-context')">(voir plus)</a><br>                            
                    </article>

                    <article class="article" id="ECS">
                        <div class="text Header-2">Pourquoi l'Entity Component System ?</div>
                        <div class="text">
                            La gestion des "objets" de jeu est donc r√©alis√©e par l'utilisation d'une technologie <abbr title="Entity Component System">ECS</abbr>.
                            L'ECS est une m√©thode de programmation bas√©e sur le paradigme de programmation : <abbr title="Data Driven Programming">DDP</abbr> ou encore du <abbr title="Data Oriented Programming">DOP</abbr>.
                            L'id√©e est de baser la programmation non plus sur des objets mais sur les informations qu'ils contiennent.
                        </div>
                        <div class="text">        
                            Aujourd'hui le paradigme de programmation le plus enseign√© est l'<abbr title="Object Oriented Programming">OOP</abbr>, celui comporte 2 d√©fauts qui nous int√©resses. 
                            Un manque de flexibilit√© et le cache miss. Prenons pour exemple un jeu dans lequel vous avez une classe "human" et une classe "goblin", vous voulez pouvoir des gobelins guerrier et des humains vendeurs. Pour se faire on peut cr√©er une classe HumainShopkeeper h√©ritant de human et une classe goblinWarrior h√©ritant de goblin.
                            Mais pour faire un gobelin vendeur il vous faudra cr√©er une troisi√®me classe, ce qui n'est pas tr√®s flexible.
                        </div>
                        <div class="text">
                            C'est pour cette raison que dans le monde du jeu vid√©o le paradigme de programmation le plus utilis√© aujourd'hui est le <abbr title="Component Based Programming">CBP</abbr>. 
                            Ce dernier se base sur des objets, qu'on appelle "composants", que l'on rattache √† d'autres objets pour leur donner des comportements ou donn√©es diff√©rentes sans augmenter la complexit√©e de l'architecture.
                            En reprenant notre exemple pr√©c√©dent des humains et des gobelins, nous aurions deux objets principaux "Human" et "Goblin" et deux composants "Shopkeeper" et "Warrior" que l'on rattacheraient √† nos objets principaux. C'est plus flexible et plus √©volutif.
                        </div>
                        <div class="text">
                            Cependant cela ne r√®gle pas le probl√®me du cache miss. Ce dernier est un probl√®me li√© √† comment l'information est stock√©e en m√©moire dans nos ordinateurs et comment le processeur y acc√®de.
                            Quand le processeur veut acc√©der √† de la m√©moire pour effectuer des actions il va prendre un "morceau" d'une certaine taille dans la RAM. Ce qui veut dire que s'il veut acceder aux informations d'un objet, il y a des chances qu'il prenne des informations inutiles a l'action qu'il doit effectuer.
                            Cela peut causer des probl√®mes de performance notamment quand les informations sont stock√©s a des endroit diff√©rents dans la m√©moire, comme cela pourrait √™tre le cas avec des listes chain√©es.
                            Ce que l'ECS tend √† faire est de stocker toutes les informations les plus proche possible les unes des des autres, comme avec un tableau. Les composants en ECS sont compos√©s exclusivement de donn√©es et le plus possible de donn√©es contigu√´.
                            Les Syst√®mes quand √† eux sont exclusivements des actions, des fonctions, du code, qui influra sur les entit√©s possedant les composant n√©cessaire √† son fonctionnement. Ainsi comme les informations sont le plus constante et continue possible on √©vite le cache miss.
                        </div>
                        <div class="text">
                            Suite √† ces recherches sur l'ECS j'ai commenc√© √† concevoir un d√©but de biblioth√®que logicielle que j'allais utiliser avec la SFML (API avec laquelle je suis familier) pour tester et apporter des modifications √† cette library.
                            Voici un diagramme de classe repr√©sentant son √©tat lors de la pr√©sentation de fin d'ann√©e d'√©tude.  
                        </div>
                        <img id="ECS-UML" src="res/imgs/placeholder.png" alt="UML class diagram ECS"></img>
                    </article>

                    <article class="article" id="OpenGL">
                        <div class="text Header-2">Choix de la biblioth√®que graphique :</div>
                        <div class="text">
                            Un domaine de la programmation avec lequel j'√©tais le plus √©tranger √©tait la programmation graphique. J'en connaissais les fondements et les principes mais pas comment utiliser les APIs.
                            La premi√®re chose √† faire √©tait de choisir une API. Je savais qu'il existait : DirectX, Metal, Vulkan ou encore OpenGL. DirectX √©tant uniquement d√©di√©e √† Windows et Metal √† MacOS  je les ait mises de cot√© pour commencer.
                            Il me restait √† choisir entre Vulkan et OpenGL. Vulkan √©tant plus r√©cent et mis a jour, contrairement √† OpenGL depuis 2016, je me suis renseigner dessus. Au vu de la complexit√© et de mon objectif final, qui √©tait de faire un prototype de moteur
                            et non uniquement un moteur de rendu j'ai pr√©f√©r√© opter pour OpenGL. De plus ce dernier est encore tr√®s pr√©sent dans l'industrie et poss√®de beaucoup plus de tutoriels pour apprendre son fonctionnement. 
                        </div>
                    </article>

                    <article class="article" id="roadmap">
                        <div class="paragraph">    
                            Flood n'est, pour le moment, disponible que sous Windows et utilise OpenGL pour le rendu, il sera a terme, dans l'id√©al, multiplateforme et permettra de choisir l'API graphique.
                            <br><br>Roadmap:<br>
                            <br>Ajouter un gestionnaire d'assets.
                            <br>Ajouter du son avec OpenAL ou via un moteur de son disponible (FMod, Wwise...).
                            <br>Retravailler l'API graphique en ajoutant Vulkan.
                            <br>Modifier l'API ECS afin d'en am√©liorer les performance g√©n√©rale (m√©moire, simplicit√©e d'utilisation, automatisation, etc...)
                        </div>
                    </article>

                    <div class="paragraph text" id="project-footer">
                        <p class="text footer-crea">Projet cr√©√© dans le cadre de fin d'√©tude √† <a class="hlink" href="www.creajeux.fr">Creajeux</a> l'√©cole des m√©tiers du jeu-vid√©o √† N√Æmes en France.</p>
                    </div>
                </div>
            </div>
        </main>
        <script src="js/Portfolio-JS.js">
            PushTagsInGrid("flood");
        </script>
    </body>
</html>


